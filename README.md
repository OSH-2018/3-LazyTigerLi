# 总体设计

- 采用类似于ext2文件系统的设计，但是是极大的简化版本，每个块组的块组描述符只记录了当前块剩余的空闲块数量。
  其余的就和ext2文件系统类似：超级块、inode表、inode位图、块位图、数据块。
- 实现了多级寻址，但只实现了两级，所以文件系统支持的最大大小为12KB`*`4+4MB+4GB。但对于根目录的数据块（根目录下的文件信息（文件名和inode编号）是存放在根目录对应的数据块中的）没有实现多级寻址，所以根目录下最多只能放12`*`32个文件。其实只要实现一个一级寻址，就可以放12`*`32+1024`*`32个文件了。

# 具体细节

- 文件空间总大小4GB
- 每个块的大小4KB
- 总共32个块组，每个块组中有32768个块，其中30717个块是数据块
- 有关文件系统的信息，如文件系统空间大小、块大小、块的数量、块组个数、块组的地址、根目录节点的地址等等，都存放在超级块中
- 在init函数中预先mmap了inode位图、块位图、块组描述符、inode表对应的空间。数据块是动态分配的。
- 在init函数中，根目录是作为一个文件创建的，之后在根目录下创建文件时，首先要把文件信息存放到根目录的对应的数据块中，
  为此实现了一个函数addItemInDirectory(void *dir,const char *filename,int32_t inode_index)，所以如果后续想要实现多级目录也是比较容易的。
- 文件名（最长124B）和文件对应的inode节点编号（4B）总共128B，存放在根目录对应的数据块中
- 多级寻址采用是多层循环的方式实现的，写起来比较麻烦。感觉多级寻址的逻辑用递归实现比较清晰，有点类似于深度优先搜索。但不知道用递归性能会怎么样。
- inode表中的每个inode节点的大小为256B，其中144B存放stat，60B存放索引（剩下的52B只好浪费）
- 支持修改文件属性，但仅限于chown,chgrp,chmod命令

# 其他

- 调试时发现fuse写文件时，一次最多写入4KB。

- 调试时发现fuse读文件时，尝试读的size总是4K的整数倍，offset也总是4K的整数倍。

- 由于我设计的块大小恰好是4KB，所以以上两点比较大地简化了write函数和read函数的设计。如果以上不是普遍标准，那么我的程序可能就要出错了。
